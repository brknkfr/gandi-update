#!/usr/bin/env bash
#
# This script updates a zone record using the API of Gandi.net 
# (http://doc.livedns.gandi.net/) and notifies by mail upon errors. 
# Ideally, this script runs as a cronjob or systemd.timer unit. If the zone 
# record doesn't exist yet, it gets created.
#
# Create a configuration file under /etc/default/gandi-updat containing the
# mandatory variables APIKEY, RECORD and DOMAIN. Adapt the other variables 
# to your needs.
# Set DNS_SERVER to query the current IP address of a host from a specific 
# DNS server.
# Set UPDATE_MSG to get a notification upon a successful update.
# The packages "curl" and "coreutils" are required. A "host" command (for 
# example from "bind9-utils package) is required aswell.
#
# Mandatory variables:
#RECORD="www"
#DOMAIN="domain.tld"
#APIKEY="string"
# Optional variables (working mail system needed for mail notification):
#MAIL="notification-email@address"
#UPDATE_MSG="IP updated for $FQDN." # Message to send upon IP update.
#TIMEOUT="5"
#DNS_SERVER="9.9.9.9"
#TTL="300"
#API="https://api.gandi.net/v5/livedns/"
#IP_SERVICE="https://ifconfig.co/"

set -euo pipefail

# Get and set variables
. "/etc/default/gandi-update"
RECORD=${RECORD:-}
DOMAIN=${DOMAIN:-}
APIKEY=${APIKEY:-}
MAIL=${MAIL:-$(whoami)}
UPDATE_MSG=${UPDATE_MSG:-}
DNS_SERVER=${DNS_SERVER:-}
TTL=${TTL:-300}
TIMEOUT=${TIMEOUT:-5}
API=${API:-https://api.gandi.net/v5/livedns/}
IP_SERVICE=${IP_SERVICE:-https://ifconfig.co}
SENDMAIL=${SENDMAIL:-/usr/sbin/sendmail}
SILENT="${SILENT:-false}"
FORCE_UPDATE_DAYS="${FORCE_UPDATE_DAYS:-1}"

# Script variables
SCRIPTNAME=$(basename "$0")
HOSTNAME=$(hostname --long)
LC_ALL=C # Speed up grep

# Lockfile, not running as systemd service
if [[ "active" != $(systemctl is-active gandi-update.timer) ]]; then
	LOCKFILE="/tmp/$SCRIPTNAME-lockfile"
    exec {FD}<>"$LOCKFILE" || exit 1
    flock -n "$FD" || { echo "[$SCRIPTNAME] Already running." >&2; exit 1; }
    # Be silent, we are probabley running on a cronjob, only print errors.
    SILENT="${SILENT:-true}"
fi

# Check mandatory variables
[[ -z "$RECORD" ]] && echo "No domain set." && exit 1
[[ -z "$DOMAIN" ]] && echo "No record set." && exit 1
[[ -z "$APIKEY" ]] && echo "No apikey set." && exit 1

# Curl args
CURL_ARGS="-m $TIMEOUT"
[[ "$SILENT" == "true" ]] && CURL_ARGS="$CURL_ARGS --silent --output /dev/null"

# Function variables
if [[ "$RECORD" == "@" ]]; then
	FQDN="$DOMAIN"
else
	FQDN="${RECORD}"."${DOMAIN}"
fi
CACHE_FILE="/tmp/$SCRIPTNAME-$(echo "$FQDN" | tr -cd '[:alnum:]')"

run() {
	UPDATED="false"
	MSG=""
	for VER in "4" "6"; do
		if [[ "$VER" == "4" ]]; then
			REGEXP='[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
			TYPE="A"
			IP="" && IP_DNS="" && ERROR["$VER"]=""
		elif [[ "$VER" == "6" ]]; then
			REGEXP='([a-f0-9:]+:+)+[a-f0-9]+'
			TYPE="AAAA"
			IP="" && IP_DNS="" && ERROR["$VER"]=""
		fi
		if get_public_ip; then
			[[ $SILENT == "false"  ]] && echo "My public IPv$VER address is $IP."
			if resolve_ip; then
				[[ $SILENT == "false"  ]] && echo "The host $FQDN is resolving to $IP_DNS."
				if cache_ip; then
					if get_record; then
						if update_ip; then
							[[ $SILENT == "false"  ]] && echo "Updated $FQDN to IPv$VER address $IP." && UPDATED="true"
						else
							ERROR[$VER]="Could not update IPv$VER address for $FQDN to $IP."
						fi
					else
						if create_record; then
							[[ $SILENT == "false" ]] && echo "Created DNS entry for $FQDN with IPv$VER address $IP."
						else
							ERROR["$VER"]="Could not create DNS entry for $FQDN with IPv$VER $IP."
						fi
					fi
				else
					[[ $SILENT == "false" ]] && echo "No IPv$VER update needed for host $FQDN."
				fi
			else
				ERROR["$VER"]="Could not resolve IPv$VER address of $FQDN."
			fi
		else
			ERROR["$VER"]="Could not get public IPv$VER address from $IP_SERVICE."
		fi
	done
	notify
}

get_public_ip() {
	IP=$(curl -s -"$VER" "$IP_SERVICE" | grep -oE "$REGEXP" | head -1) || return 1
}

resolve_ip() {
	IP_DNS=$(host -W "$TIMEOUT" "$FQDN" $DNS_SERVER | grep -oE "address $REGEXP" | grep -oE "$REGEXP") || return 1
}

cache_ip() {
	[[ -f "$CACHE_FILE"-"$VER" ]] && find "$CACHE_FILE-$VER" -type f -mtime +"$FORCE_UPDATE_DAYS" -delete
	[[ ! -f "$CACHE_FILE"-"$VER" ]] && echo "$IP" > "$CACHE_FILE"-"$VER"
	if [[ "$(cat "$CACHE_FILE"-"$VER")" != "$IP" || "$IP_DNS" != "$IP" ]]; then
		echo "$IP" > "$CACHE_FILE"-"$VER"
	else
		return 1
	fi
}

get_record() {
	RECORD_CHECK=$(curl -s -H 'Content-Type: application/json' \
		-H "Authorization: Apikey $APIKEY" \
		"$API/domains/$DOMAIN/records/$RECORD/$TYPE")
	echo "$RECORD_CHECK" | grep -q "\"rrset_name\":\"$RECORD\"" || return 1
}

create_record() {
	SET_RECORD_DATA='{
		"rrset_ttl":"'$TTL'",
		"rrset_values": ["'$IP'"]
	}'
	curl "$CURL_ARGS" -X POST -H 'Content-Type: application/json' \
		-H "Authorization: Apikey $APIKEY" \
		-d "$SET_RECORD_DATA" \
		"$API/domains/$DOMAIN/records/$RECORD/$TYPE" || return 1
}

update_ip() {
	SET_RECORD_DATA='{
		"rrset_ttl":"'$TTL'",
		"rrset_values": ["'$IP'"]
	}'
	curl "$CURL_ARGS" -X PUT -H 'Content-Type: application/json' \
		-H "Authorization: Apikey $APIKEY" \
		-d "$SET_RECORD_DATA" \
		"$API/domains/$DOMAIN/records/$RECORD/$TYPE" || return 1
}

notify() {
	[[ -n "${ERROR[4]}" ]] && MSG="${ERROR[4]}"$'\n' && echo "${ERROR[4]}"
	[[ -n "${ERROR[6]}" ]] && MSG+="${ERROR[6]}" && echo "${ERROR[6]}"
	if [[ -n "$MAIL" && -n "$MSG" && -x "$SENDMAIL" ]]; then
		echo -e "To: $MAIL\nSubject: [$SCRIPTNAME] IP address error for $FQDN on $HOSTNAME\n\n$MSG" | "$SENDMAIL" -t
	elif [[ "$UPDATED" == "true" && -n "$UPDATE_MSG" ]]; then
		echo -e "To: $MAIL\nSubject: [$SCRIPTNAME] IP address updated for $FQDN on $HOSTNAME\n\n$UPDATE_MSG" | "$SENDMAIL" -t
	fi
}

run
